{
  "language": "Solidity",
  "sources": {
    "contracts/IDataVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IDataVerifier Interface\n * @notice Interface for data verification systems supporting different proof mechanisms\n * @dev Supports both TEE and ZKP verification methods for ERC-7857 AI Agent NFTs\n */\ninterface IDataVerifier {\n    /**\n     * @dev Output structure for ownership proof verification\n     * @param dataHashes Array of validated data hashes from the proof\n     * @param isValid Whether the ownership proof is valid\n     */\n    struct OwnershipProofOutput {\n        bytes32[] dataHashes;\n        bool isValid;\n    }\n\n    /**\n     * @dev Output structure for transfer validity proof verification\n     * @param oldDataHashes Array of original data hashes before transfer\n     * @param newDataHashes Array of new data hashes after re-encryption\n     * @param pubKey Public key of the recipient for secure key transfer\n     * @param sealedKey Encrypted key sealed for the recipient\n     * @param isValid Whether the transfer validity proof is valid\n     */\n    struct TransferValidityProofOutput {\n        bytes32[] oldDataHashes;\n        bytes32[] newDataHashes;\n        bytes pubKey;\n        bytes sealedKey;\n        bool isValid;\n    }\n\n    /**\n     * @notice Verify ownership of data through cryptographic proof\n     * @dev Verifies that the prover possesses the original data by demonstrating \n     *      knowledge of pre-images that generate the claimed dataHashes\n     * @param _proof Cryptographic proof generated by companion prover system\n     * @return OwnershipProofOutput containing verification result and validated data hashes\n     */\n    function verifyOwnership(\n        bytes calldata _proof\n    ) external returns (OwnershipProofOutput memory);\n\n    /**\n     * @notice Verify validity of data transfer operation\n     * @dev Verifies secure data integrity and availability by proving:\n     *      - Knowledge of original data (pre-images of oldDataHashes)\n     *      - Ability to decrypt with oldKey and re-encrypt with newKey\n     *      - Secure transmission of newKey using recipient's public key\n     *      - Integrity of newly encrypted data matching newDataHashes\n     *      - Data availability confirmed by recipient's signature\n     * @param _proof Cryptographic proof generated by companion prover system\n     * @return TransferValidityProofOutput containing verification result and transfer details\n     */\n    function verifyTransferValidity(\n        bytes calldata _proof\n    ) external returns (TransferValidityProofOutput memory);\n}"
    },
    "contracts/MockSapphire.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// Mock Sapphire contracts for local development\n// These provide the same interface as real Sapphire contracts but without TEE functionality\n\ncontract MockSapphire {\n    // Mock storage for API keys (in production this would be TEE-protected)\n    mapping(bytes32 => bytes) private _mockROFLStorage;\n    mapping(bytes32 => bool) private _keyExists;\n    mapping(address => bool) private _authorizedOrigins;\n    \n    // Events for testing and debugging\n    event ROFLStorageSet(bytes32 indexed key, uint256 dataLength);\n    event ROFLStorageAccessed(bytes32 indexed key, address accessor);\n    event ROFLAuthorizationCheck(address origin, bool authorized);\n    event APIKeyEncrypted(bytes32 indexed keyHash);\n    event APIKeyDecrypted(bytes32 indexed keyHash, address accessor);\n    \n    // Mock encryption/decryption for testing\n    function mockEncrypt(bytes memory data) internal pure returns (bytes memory) {\n        // Simple XOR encryption for testing (NOT secure, only for development)\n        bytes memory encrypted = new bytes(data.length);\n        for (uint i = 0; i < data.length; i++) {\n            encrypted[i] = bytes1(uint8(data[i]) ^ 0xAA);\n        }\n        return encrypted;\n    }\n    \n    function mockDecrypt(bytes memory encryptedData) internal pure returns (bytes memory) {\n        // Simple XOR decryption for testing (NOT secure, only for development)\n        bytes memory decrypted = new bytes(encryptedData.length);\n        for (uint i = 0; i < encryptedData.length; i++) {\n            decrypted[i] = bytes1(uint8(encryptedData[i]) ^ 0xAA);\n        }\n        return decrypted;\n    }\n    \n    // Mock ROFL authorization - configurable for testing\n    function roflEnsureAuthorizedOrigin() internal returns (bool) {\n        // In real Sapphire, this validates TEE execution environment\n        // For local development, we simulate authorization checks\n        bool authorized = _authorizedOrigins[msg.sender] || _authorizedOrigins[tx.origin] || true;\n        emit ROFLAuthorizationCheck(msg.sender, authorized);\n        return authorized;\n    }\n    \n    // Mock rofl storage interface\n    struct ROFLStorageInterface {\n        mapping(bytes32 => bytes) data;\n    }\n    \n    ROFLStorageInterface internal roflStorage;\n    \n    // Enhanced mock implementation for setting storage with encryption\n    function _setROFLStorage(bytes32 key, bytes calldata value) internal {\n        require(value.length > 0, \"Empty data not allowed\");\n        \n        // Mock encryption of the API key\n        bytes memory encryptedValue = mockEncrypt(value);\n        _mockROFLStorage[key] = encryptedValue;\n        _keyExists[key] = true;\n        \n        emit ROFLStorageSet(key, value.length);\n        emit APIKeyEncrypted(key);\n    }\n    \n    // Enhanced mock implementation for getting storage with decryption\n    function _getROFLStorage(bytes32 key) internal returns (bytes memory) {\n        require(_keyExists[key], \"Key does not exist in TEE storage\");\n        \n        bytes memory encryptedData = _mockROFLStorage[key];\n        bytes memory decryptedData = mockDecrypt(encryptedData);\n        \n        emit ROFLStorageAccessed(key, msg.sender);\n        emit APIKeyDecrypted(key, msg.sender);\n        \n        return decryptedData;\n    }\n    \n    // Mock function to simulate private agent access verification\n    function _verifyAgentAccess(\n        uint256 agentId,\n        address user,\n        bool isPrivate\n    ) internal pure returns (bool) {\n        if (!isPrivate) {\n            return true; // Public agents are always accessible\n        }\n        \n        // In real implementation, this would check TEE-protected access lists\n        // For mock, we simulate the check\n        return agentId > 0 && user != address(0);\n    }\n    \n    // Mock function to add authorized origins (for testing)\n    function _addAuthorizedOrigin(address origin) internal {\n        _authorizedOrigins[origin] = true;\n    }\n    \n    // Mock function to remove authorized origins (for testing)\n    function _removeAuthorizedOrigin(address origin) internal {\n        _authorizedOrigins[origin] = false;\n    }\n    \n    // Mock function to check if a key exists in storage\n    function _keyExistsInStorage(bytes32 key) internal view returns (bool) {\n        return _keyExists[key];\n    }\n    \n    // Mock function to get storage size (for testing)\n    function _getStorageSize(bytes32 key) internal view returns (uint256) {\n        if (!_keyExists[key]) return 0;\n        return _mockROFLStorage[key].length;\n    }\n    \n    // Mock function to clear storage (for testing)\n    function _clearROFLStorage(bytes32 key) internal {\n        delete _mockROFLStorage[key];\n        delete _keyExists[key];\n    }\n    \n    // Mock function to simulate TEE environment check\n    function _isInTEE() internal pure returns (bool) {\n        // In real Sapphire, this would check if running in TEE\n        // For mock, we always return true in development\n        return true;\n    }\n}"
    },
    "contracts/OasisTEEVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./IDataVerifier.sol\";\n// Mock Sapphire for local development - replace with real import for production\n// import \"@oasisprotocol/sapphire/contracts/Sapphire.sol\";\nimport \"./MockSapphire.sol\";\n\n/**\n * @title OasisTEEVerifier\n * @notice TEE-based data verification system for ERC-7857 AI Agent NFTs\n * @dev Implements IDataVerifier interface using Oasis ROFL-Sapphire for secure verification\n * @custom:security All verifications must occur within TEE environment using roflEnsureAuthorizedOrigin()\n */\ncontract OasisTEEVerifier is IDataVerifier, MockSapphire {\n    \n    // Track used nonces to prevent replay attacks\n    mapping(bytes32 => bool) private usedNonces;\n    \n    // TEE attestation verification keys (would be configured during deployment)\n    mapping(bytes32 => bool) public trustedTEEKeys;\n    \n    event ProofVerified(\n        bytes32 indexed proofHash, \n        bool isValid, \n        address indexed verifier\n    );\n    \n    event NonceUsed(bytes32 indexed nonce, address indexed user);\n    \n    constructor() {\n        // Initialize with trusted TEE public keys\n        // In production, these would be Oasis TEE attestation keys\n        _initializeTrustedKeys();\n    }\n    \n    /**\n     * @notice Verify ownership of AI agent data through TEE attestation\n     * @dev Must be called within TEE environment for security\n     * @param _proof TEE attestation proof containing data hashes and signature\n     * @return OwnershipProofOutput with validation result and data hashes\n     */\n    function verifyOwnership(bytes calldata _proof) \n        external override returns (OwnershipProofOutput memory) {\n        \n        // ✅ CRITICAL: Ensure execution within TEE\n        if (block.chainid == 23295 || block.chainid == 23294) {\n            require(roflEnsureAuthorizedOrigin(), \"Must execute in TEE\");\n        }\n        \n        // Decode TEE attestation proof structure\n        (\n            bytes32[] memory dataHashes,\n            bytes memory teeAttestation,\n            bytes32 nonce,\n            uint256 timestamp\n        ) = abi.decode(_proof, (bytes32[], bytes, bytes32, uint256));\n        \n        // Validate proof components\n        require(dataHashes.length > 0, \"No data hashes provided\");\n        require(teeAttestation.length > 0, \"No TEE attestation provided\");\n        require(!usedNonces[nonce], \"Nonce already used\");\n        require(timestamp > block.timestamp - 300, \"Proof too old\"); // 5 minute validity\n        \n        // For development/testing: simplified validation\n        // In production, this would verify actual TEE attestations\n        bool isValid = dataHashes.length > 0 && \n                      teeAttestation.length > 0 && \n                      timestamp > block.timestamp - 300;\n        \n        if (isValid) {\n            // Mark nonce as used (note: this is view function, so nonce isn't actually marked)\n            // In practice, nonce marking would happen in a separate transaction\n            emit ProofVerified(keccak256(_proof), isValid, msg.sender);\n        }\n        \n        return OwnershipProofOutput({\n            dataHashes: dataHashes,\n            isValid: isValid\n        });\n    }\n    \n    /**\n     * @notice Verify validity of data transfer with re-encryption proof\n     * @dev Validates secure data transfer between parties through TEE\n     * @param _proof TEE proof containing old/new hashes, keys, and attestation\n     * @return TransferValidityProofOutput with transfer validation details\n     */\n    function verifyTransferValidity(bytes calldata _proof) \n        external override returns (TransferValidityProofOutput memory) {\n        \n        // ✅ CRITICAL: Ensure execution within TEE\n        if (block.chainid == 23295 || block.chainid == 23294) {\n            require(roflEnsureAuthorizedOrigin(), \"Must execute in TEE\");\n        }\n        \n        // Decode comprehensive transfer proof\n        (\n            bytes32[] memory oldDataHashes,\n            bytes32[] memory newDataHashes,\n            bytes memory recipientPubKey,\n            bytes memory sealedKey,\n            bytes memory teeAttestation,\n            bytes32 nonce,\n            uint256 timestamp\n        ) = abi.decode(_proof, (bytes32[], bytes32[], bytes, bytes, bytes, bytes32, uint256));\n        \n        // Validate all proof components\n        require(oldDataHashes.length == newDataHashes.length, \"Hash arrays length mismatch\");\n        require(oldDataHashes.length > 0, \"No data hashes provided\");\n        require(recipientPubKey.length > 0, \"No recipient public key\");\n        require(sealedKey.length > 0, \"No sealed key provided\");\n        require(!usedNonces[nonce], \"Nonce already used\");\n        require(timestamp > block.timestamp - 300, \"Proof too old\");\n        \n        // For development/testing: simplified validation\n        // In production, this would verify actual TEE attestations\n        bool isValid = oldDataHashes.length == newDataHashes.length &&\n                      oldDataHashes.length > 0 &&\n                      recipientPubKey.length > 0 &&\n                      sealedKey.length > 0 &&\n                      teeAttestation.length > 0 &&\n                      timestamp > block.timestamp - 300;\n        \n        if (isValid) {\n            emit ProofVerified(keccak256(_proof), isValid, msg.sender);\n        }\n        \n        return TransferValidityProofOutput({\n            oldDataHashes: oldDataHashes,\n            newDataHashes: newDataHashes,\n            pubKey: recipientPubKey,\n            sealedKey: sealedKey,\n            isValid: isValid\n        });\n    }\n    \n    /**\n     * @dev Verify TEE attestation for ownership proofs\n     * @param attestation TEE signature/attestation data\n     * @param dataHashes Array of data hashes being verified\n     * @param nonce Unique nonce to prevent replays\n     * @param timestamp Proof generation timestamp\n     * @return bool indicating if attestation is valid\n     */\n    function _verifyTEEAttestation(\n        bytes memory attestation,\n        bytes32[] memory dataHashes,\n        bytes32 nonce,\n        uint256 timestamp\n    ) private view returns (bool) {\n        \n        // Create message hash for verification\n        bytes32 messageHash = keccak256(abi.encodePacked(\n            dataHashes,\n            nonce,\n            timestamp,\n            msg.sender,\n            \"OWNERSHIP_PROOF\"\n        ));\n        \n        // Verify against trusted TEE keys\n        return _verifyTEESignature(messageHash, attestation);\n    }\n    \n    /**\n     * @dev Verify TEE attestation for transfer validity proofs  \n     * @param attestation TEE signature/attestation data\n     * @param oldDataHashes Original data hashes before transfer\n     * @param newDataHashes New data hashes after re-encryption\n     * @param pubKey Recipient's public key\n     * @param sealedKey Encrypted key for recipient\n     * @param nonce Unique nonce to prevent replays\n     * @param timestamp Proof generation timestamp\n     * @return bool indicating if attestation is valid\n     */\n    function _verifyTransferAttestation(\n        bytes memory attestation,\n        bytes32[] memory oldDataHashes,\n        bytes32[] memory newDataHashes,\n        bytes memory pubKey,\n        bytes memory sealedKey,\n        bytes32 nonce,\n        uint256 timestamp\n    ) private view returns (bool) {\n        \n        // Create comprehensive message hash\n        bytes32 messageHash = keccak256(abi.encodePacked(\n            oldDataHashes,\n            newDataHashes,\n            pubKey,\n            keccak256(sealedKey),\n            nonce,\n            timestamp,\n            msg.sender,\n            \"TRANSFER_PROOF\"\n        ));\n        \n        // Verify against trusted TEE keys\n        return _verifyTEESignature(messageHash, attestation);\n    }\n    \n    /**\n     * @dev Verify signature against trusted TEE public keys\n     * @param messageHash Hash of the message being verified\n     * @param signature TEE signature to verify\n     * @return bool indicating if signature is valid\n     */\n    function _verifyTEESignature(bytes32 messageHash, bytes memory signature) \n        private view returns (bool) {\n        \n        // In production, this would:\n        // 1. Extract public key from TEE attestation\n        // 2. Verify against Oasis TEE attestation format\n        // 3. Check against trusted TEE key registry\n        \n        // For demo/testing: simplified validation\n        if (signature.length < 32) return false;\n        \n        // In development mode, accept signatures that match a known pattern\n        // This is NOT secure - only for testing!\n        bytes32 expectedSig = keccak256(abi.encodePacked(\"mock-signature\"));\n        bytes32 providedSig = keccak256(signature);\n        \n        return providedSig == expectedSig || trustedTEEKeys[providedSig];\n    }\n    \n    /**\n     * @dev Initialize trusted TEE public keys during deployment\n     */\n    function _initializeTrustedKeys() private {\n        // In production, these would be Oasis ROFL-Sapphire attestation keys\n        // For demo: add some test keys\n        trustedTEEKeys[keccak256(abi.encodePacked(address(0x1)))] = true;\n        trustedTEEKeys[keccak256(abi.encodePacked(address(0x2)))] = true;\n    }\n    \n    /**\n     * @notice Add trusted TEE key (admin only)\n     * @dev Would be used to register new TEE attestation keys\n     * @param keyHash Hash of the TEE public key to trust\n     */\n    function addTrustedTEEKey(bytes32 keyHash) external {\n        // In production, only TEE infrastructure should be able to call this\n        if (block.chainid == 23295 || block.chainid == 23294) {\n            require(roflEnsureAuthorizedOrigin(), \"Must execute in TEE\");\n        }\n        \n        trustedTEEKeys[keyHash] = true;\n    }\n    \n    /**\n     * @notice Mark nonce as used (separate transaction to handle view function limitation)\n     * @param nonce The nonce to mark as used\n     */\n    function markNonceUsed(bytes32 nonce) external {\n        require(!usedNonces[nonce], \"Nonce already used\");\n        usedNonces[nonce] = true;\n        emit NonceUsed(nonce, msg.sender);\n    }\n    \n    /**\n     * @notice Check if a nonce has been used\n     * @param nonce The nonce to check\n     * @return bool indicating if nonce is used\n     */\n    function isNonceUsed(bytes32 nonce) external view returns (bool) {\n        return usedNonces[nonce];\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}